// Usage: opt -load-pass-plugin=libUnitProject.so -passes="unit-sccp"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Instructions.h"

#include <map>
#include <set>

#include "UnitSCCP.h"

#define DEBUG_TYPE UnitSCCP
// Define any statistics here

enum ValueType {
  TOP, BOTTOM, CONSTANT
};

struct Value_ {
  ValueType type;
  std::string varname = "";
  std::string value = "";

  // this function generated by ChatGPT
  friend bool operator==(const Value_& lhs, const Value_& rhs) {
        return lhs.type == rhs.type &&
               lhs.varname == rhs.varname &&
               lhs.value == rhs.value;
  }
  friend bool operator!=(const Value_& lhs, const Value_& rhs) {
    return !(lhs == rhs);
  }
};

ValueType meet(Value_ first, Value_ second) {
  if (first.type == BOTTOM || second.type == BOTTOM) {
    return BOTTOM;
  }

  if (first.type == TOP && second.type == TOP) {
    return TOP;
  }

  if ((first.type == CONSTANT && second.type == TOP) &&
      (second.type == CONSTANT && first.type == TOP)) {
    return CONSTANT;
  }

  if (first.type == CONSTANT && second.type == CONSTANT &&
    first.value == second.value) {
      return CONSTANT;
    }

  return BOTTOM;
}

using namespace llvm;
using namespace cs426;

typedef std::pair<Instruction*, Instruction*> Edge;

// Globals used in analysis
std::map<Edge, bool> execFlags;
std::map<Instruction*, Value_> latCell;

std::vector<Edge> flowWL;
std::vector<Edge> ssaWL;

Value_ evaluate(Instruction *inst) {
  // FIXME
}

Value *genLLVMValue(Value_ latticeValue) {
  // FIXME
}

std::set<Instruction*> successors_(Instruction *inst) {
  std::set<Instruction*> next_instrs = std::set<Instruction*>();

  // if there's a branch we need both sides of the branch
  if (isa<BranchInst>(inst)) {
    BasicBlock *BB = inst->getParent();
    for (auto successor: successors(BB)) {
      next_instrs.insert(&successor->front());
    }
  } else {
    next_instrs.insert(inst->getNextNode());
  }

  return next_instrs;
}

void visitInst(Instruction *inst) {
  Value_ val = evaluate(inst);
  Value_ valPrev;

  try {
    valPrev = latCell.at(inst);
  } catch (const std::out_of_range& e) {
    valPrev = Value_();
    valPrev.type = TOP;
  };

  latCell[inst] = val;

  if (val != valPrev) {
    // check if it's an assignment by checking if the return type is non-void
    if (!inst->getType()->isVoidTy()) {
      // add SSAOutEdges(S) to SSAWL
      for (User *user: inst->users()) {
        ssaWL.push_back(
          Edge(inst, dyn_cast<Instruction>(user))
        );
      }
    } else { // S is a branch instruction
      if (val.type == CONSTANT) {
        // FIXME - add constant outgoing edge to flowWL
      } else {
        for (Instruction *successor: successors_(inst)) {
          flowWL.push_back(Edge(inst, successor));
        }
      }
    }

  }

}

void visitPhi(Instruction *inst) {
  // FIXME - convert inst to a phi
  PHINode *phi = dyn_cast<PHINode>(inst);
  unsigned numOperands = phi->getNumIncomingValues();

  for (unsigned i = 0; i < numOperands; ++i) {
    Value *incomingValue = phi->getIncomingValue(i);
  }
}

/// Main function for running the SCCP optimization
PreservedAnalyses UnitSCCP::run(Function& F, FunctionAnalysisManager& FAM) {
  dbgs() << "UnitSCCP running on " << F.getName() << "\n";

  // Initialize values
  execFlags = std::map<Edge, bool>();
  latCell = std::map<Instruction*, Value_>();

  flowWL = {};
  ssaWL = {};

  std::set<Instruction*> visited = std::set<Instruction*>();

  // visit the first instruction
  Instruction *first = &F.front().front();
  visitInst(first);

  // find the successors of the inst
  // add the edges to flowWL
  for (auto successor: successors_(first)) {
    flowWL.push_back(Edge(
      first, successor
    ));
  }

  // main loop of SCCP
  while (!flowWL.empty() || !ssaWL.empty()) {
    if (!flowWL.empty()) {
      Edge edge = flowWL.back();
      flowWL.pop_back();

      try {
        if (execFlags.at(edge)) continue;
      } catch (const std::out_of_range& e) {
        // false by default, so continue on current iteration
      };

      execFlags[edge] = true;

      if (isa<PHINode>(edge.second)) {
        visitPhi(edge.second);
      }

      // FIXME - is this supposed to be else if?
      if (!visited.contains(edge.second)) {
        visitInst(edge.second);
      }

      // if only one outgoing edge, add to flowWL
      std::set<Instruction*> next_instrs = successors_(edge.second);
      if (next_instrs.size() == 1) {
        for (Instruction* item : next_instrs) {
          flowWL.push_back(Edge(edge.second, item));
        }
      }

      // This needs to be at the end so it doesn't interfere with the other checks
      visited.insert(edge.second);

    }

    else if (!ssaWL.empty()) {
      Edge edge = ssaWL.back();
      ssaWL.pop_back();

      if (isa<PHINode>(edge.second)) {
        visitPhi(edge.second);
      } else if (execFlags[edge]) { // if (E->sink has 1 or more executable in-edges)
        visitInst(edge.second);
      }
    }
  }

  // add a second pass to replace the uses with constants
  for (auto i: latCell) {
    if (i.second.type == CONSTANT) {
      // generate the LLVM value, and replace all uses of the instruction
      i.first->replaceAllUsesWith(genLLVMValue(i.second));
    }
  }

  // Set proper preserved analyses
  return PreservedAnalyses::all();
}